# Терминология
# Массив - он же список


test_arr = [2, 1, 3, 4, 5, 6]


# 1
# написать функцию, которая обменивает местами два значения в списке/массиве
# функция принимает параметрами массив и два индекса в массиве, значения которых надо обменять

def swap(lst, index1, index2):
    t = lst[index1]
    lst[index1] = lst[index2]
    lst[index2] = t


# swap(test_arr, 1, 3)
# print(test_arr)

# 2
# Написать функцию, которая ищет в заданном массиве индекс (позицию) минимального значения в заданном диапазоне индексов
# Функция принимает параметрами массив, индекс начала поиска (откуда начинать искать) и индекс до куда искать
# (то есть ищем не во всем массиве)
# функция возвращает индекс найденного минимального значения
# просьба написать (ДЛЯ ТРЕНИРОВКИ) код этой функции своим циклом и не делать срезы в массиве


def get_min_index(lst, from_index, to_index):
    if to_index - from_index < 2:
        if to_index >= 0:
            return to_index

    min_index = from_index
    for i in range(from_index + 1, to_index + 1):
        if lst[i] < lst[min_index]:
            min_index = i
    return min_index


# min_index = get_min_index(test_arr, 1, 5)
# print(min_index)

# 3
# Написать функцию сортировки ВЫБОРОМ
# Функция принимает массив и сортирует его. Прямо его, не создавая новый.
# Иногда лучше создавать новый сортированный, иногда лучше сортировать заданный.
# В данном случае для тренировки делаем первый вариант. Представим что мы ограничены в памяти или что массив огромный


def select_sort(lst):
    n = len(lst)

    for i in range(n - 1):
        min_index = get_min_index(lst, i, n - 1)
        swap(lst, min_index, i)

    return lst

# select_sort(test_arr)
# print(test_arr)


# Как устроен алгоритм. (сортировка по возрастанию)
# Пусть массив состоит из N элементов, тогда надо сделать N-1 итераций цикла.
# В каждой итерации цикла I мы должны в массиве найти наименьший элемент, начиная с позиции I. Обмениваем его
# с элементом массива в позиции I. В начале I == 0 (начало массива), наращиваем в каждой итерации цикла
# в итоге массив отсортирован

# 4
# Написать функцию сортировки ПУЗЫРЬКОМ
# Функция принимает массив и сортирует его.

# Как устроен алгоритм.
# Пусть массив состоит из N элементов, тогда надо сделать МАКСИМУМ N-1 итераций цикла.
# В каждой итерации цикла I мы сравниваем попарно рядом стоящие элементы и если они не в правилном порядке - обменять их
# местами. Например сортируем по возрастанию. Имеем массив.  7 3 5 1 4 8 2 7
# Первый проход. (первая ИТЕРАЦИЯ внешнего цикла)
# 7 и 3 - обменять местами, получаем 3 7 5 1 4 8 2 7
# 7 и 5 - обменять - 3 5 7 1 4 8 2 7
# 7 и 1 - обменять - 3 5 1 7 4 8 2 7
# 7 и 4 - обменять - 3 5 1 4 7 8 2 7
# 7 и 8 - НЕ меняем - 3 5 1 4 7 8 2 7
# 8 и 2 - обменять - 3 5 1 4 7 2 8 7
# 8 и 7 - обменять - 3 5 1 4 7 2 7 8

# повторить N - 1 раз (максимум - если поймете почему максимум и как можно уменьшить количество циклов - доработайте,
# если нет - то строго N - 1 раз)
# в рамках следующих проходов надо доходить обменами на I элементов меньше до конца, так как на каждой итерации
# на точное место (наверх) всплывает один элемент. Например у нас 8 всплыло


print(test_arr)


def bubble_sort(lst):
    n = len(lst)

    for i in range(n - 1):
        swaps_counter = 0
        for j in range(n - 1 - i):
            if lst[j + 1] < lst[j]:
                swap(lst, j, j + 1)
                swaps_counter += 1

        if swaps_counter == 0:
            break

        print(test_arr)

    return lst


bubble_sort(test_arr)
# print(test_arr)
