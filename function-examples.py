# from Crypto.Cipher import DES

# запуская одни примеры, вы можете предварительно закомментировать другие, если они вам мешают


#                       КОЛБЕКИ

# при разработке игры змейка мы сталкнулись с применением технологии обратного вызова функции
# (он же callback, он же колбек)
# wn.onkeypress(go_up, "Up")
# о сути мы зарегистрировали функцию go_up для обработки события нажания клавишиы вверх
# (с помощью библиотеки turtle)
# С точки зрения Python мы вызвали метод onkeypress у объекта wn и дали ему два параметра - ссылку на функцию go_up
# и строку с названием клавиши.

# запоминаем, имя функции является ссылкой на саму функцию, с этим именем функции можно работать как с обычной переменной
# сохранять в другую переменную, использовать как параметр функций, сравнивать (==)
# с сылкой на функцию можно сделать еще одну операцию - вызвать функцию.
# то ест где-то внутри кода метода onkeypress  происходит выхов этой функции. Для этого к
# ссылке на функцию справа приписываются круглые скобки (). Это будет вызов функции без параметров.
# колбеки могут быть вызваны и с параметрами.

# def onkeypress(self, fun, key=None):
#     ...
#     fun()
#     ...

# так выглядит вызов колбека внутри onkeypress
#  (self - обязательный первый параметр для любого метода класса, пока это не проходим)

# колбеки могут быть использованы для разных целей
# 1. дать обработать пользовательском (нашему) коду какие-то события (например нажатие кнопок)
#  пример выше

# 2. задать обработчики для результатов асинхронной операции. Например в случае успеха или не успеха

# например так
# send_http_request(req, on_success, on_error)

# пусть в данном выдуманном примере onError принимает параметр ошибки

def on_error(error_message):
    print(error_message)


# def send_http_request(req, on_success_func, on_error_func):
    # ...
    # ...
    # if error:
    #     on_error_func(error.message)
    # ...


# 3. для динамического задания части работы функции, которая принимает колбек. По другому этом можно понимать,
# как повышение повторного использования.
# допустим у нас есть функция создания шифрованного архива
# и нам нужна эта функция с разными алгоритмами шифрования
# допустим, мы даже хотим, чтобы нашей функцией создания шифрованного архива пользовались другие программисты
# в том же или других проектах. Пуст это одна из причин почему мы не хотим жестко закодить выбор алгоритма шифрования
# например вот вариант не гибкой функции создания архива (все очень упрощено для примера)

# def create_arc(path, password, encryption_type):
#     # ..
#     if encryption_type == 'AES':
#        data = do_aes_encryption(data, password)
#     elif encryption_type == 'DES':
#        data = do_des_encryption(data, password)
#
#    # ..

# пример гибкого подхода к этой задаче

# def create_arc(path, password, encryption_func):
#     # ..
#     data = encryption_func(data, password)
#
#    # ..

# какой-то рабочий простой пример с использованием колбека


# в одном из модулей создали главную функцию, принимающую колбек

def save_to_encrypted_file(path, data, encryption_func, key):
    with open(path, "w") as file:
        encrypted_data = encryption_func(data, key)
        file.write(encrypted_data)


# совсем в другом модуле сделаю функци шифрования с помощью алгоритма DES и вызову save_to_encrypted_file

def pad(text):
    while len(text) % 8 != 0:
        text += b' '
    return text


# def des_encryption(text, key):
#     des = DES.new(key, DES.MODE_ECB)
#     padded_text = pad(text)
#     encrypted_text = des.encrypt(padded_text)
#     return encrypted_text


# save_to_encrypted_file("encrypted.txt", "test data", des_encryption, b'abcdefgh')


# ПОЗИЦИОННЫЕ И ИМЕННОВАННЫЕ АРГУМЕНТЫ ФУНКЦИЙ.

# Прошу попробовать самостоятельно почитать и пройти в Introduction to Python
# разделы Default parameters, Keyword Arguments, Argument Order, можете переводить описания переводчиком
# может быть не все понятно сразу, но к этой теме будем эпизодически возвращаться.
# сейчас прочитайте и пройдите для ознакомления (в программе caterpilar уже сталкивались с применением)


#             РЕКУРСИЯ

# Это просто, когда функция вызывает саму себя. Обязательно нужно условие выхода, иначе просто
# быстро память программы закончится на вызовах функций

# Стоит так же в Интродакшене почитать
# Пример от туда

#  Задача подсчета факториала. В начале решим её итеративно (циклами)


def factorial_1(n):
    result = 1

    for i in range(1, n + 1):
        result = result * i

    return result


def factorial_2(n):
    if n <= 1:
        return 1
    else:
        # calculate n multiplied by the factorial of n - 1
        return n * factorial_2(n - 1)


print(factorial_1(4))
print(factorial_2(4))


# работает и так и так. Важная информация.
# 1. циклы работаю быстрее
# 2. циклы расходуют меньше памяти

# Вопрос - а зачем тогда эта рекурсия.
# Рекурсией гораздо легче реализовать некоторые алгоритмические и практические задачи.
# Если доп затраты процессора и памяти на рекурсию ничтожны в рамках вашей задачи, а рекурсивно её решить легко -
# почему бы и нет!

# еще рекурсия используется для учебных примеров популярных алгоритмов

# Разберем пример алгоритма бинарного поиска
# алгоритм применяется к массивам (линейным структурам данных с
# произвольным доступом - из таких я знаю только массив). В Питоне массив называется списком.
# Обязательное условие применимости данного алгоритма - список должен быть отсортированным

array = [2, 3, 4, 6, 8, 9, 14, 26, 34, 56, 67, 78, 89, 90]

# задача - выяснить, есть ли в массиве число 78
# идея алгоритма - начать с середины, если значение в середине не искомое - но больше искомого,
# то применить тот же алгоритм для части массива слева от середины, в противно случае - для части массива справа
# продолжать, пока искомое не совпало со значением взятым в массиве.
#  Легко решается рекурсивно
# есть одна особенность - в питоне я не могу передать в функцию кусок списка - мы всегда даем ссылку на объект
# списка. Поэтоу придется в вызовах функции передавать еще и индексы начала и конца в списке, где ищем


def binary_search_includes(arr, value, index_from=None, index_to=None):
    if index_from is None:
        index_from = 0

    if index_to is None:
        index_to = len(arr) - 1

    middle_index = index_from + (index_to - index_from) // 2

    if arr[middle_index] == value:
        return True

    if middle_index == index_to == index_from:
        return False

    if arr[middle_index] > value:
        return binary_search_includes(arr, value, index_from, middle_index - 1)
    else:
        return binary_search_includes(arr, value, middle_index + 1, index_to)


print("is 78 in array? " + str(binary_search_includes(array, 78)))
print("is 79 in array? " + str(binary_search_includes(array, 79)))


# Домашнее задание - сделать binary_search_includes с помощью цикла вместо рекурсии
